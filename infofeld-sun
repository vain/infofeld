#!/usr/bin/env python

from infofeldlib import shadowed_text, write_ff

from argparse import ArgumentParser
from datetime import datetime
from math import acos, cos, sin, pi
from sys import exit, stderr

import cairo


DEG_TO_RAD = pi / 180


def sun_info(args):
    sun = {}

    now = datetime.now()
    l = now.timetuple()

    sun['current'] = l.tm_hour + (l.tm_min / 60) + (l.tm_sec / 3600)
    sun['current'] /= 24

    # Hacky and not precise, but good enough for this tool.
    tzoff = (datetime.utcnow() - datetime.now()).total_seconds() / 60

    # http://lexikon.astronomie.info/zeitgleichung/
    # (No code from that site has been used, just the mathematical
    # formulas.)
    #
    # Please note that these approximations don't work well above 60
    # degrees latitude, nor below -60 degrees.

    B = args.lat * DEG_TO_RAD
    decl = 0.4095 * sin(0.016906 * (l.tm_yday - 80.086))

    h_rise = -0.0145
    diff = 12 * acos((sin(h_rise) - sin(B) * sin(decl)) /
           (cos(B) * cos(decl))) / pi
    ZGdiff = -0.171 * sin(0.0337 * l.tm_yday + 0.465) - (0.1299 *
             sin(0.01787 * l.tm_yday - 0.168))

    local_delta = tzoff / (-60) - (args.lon / 15)
    local_rise = 12 - diff - ZGdiff + local_delta
    local_set = 12 + diff - ZGdiff + local_delta
    local_noon = local_rise + diff

    sun['rise'] = local_rise / 24
    sun['noon'] = local_noon / 24
    sun['set'] = local_set / 24

    return sun


def float_to_time(f):
    f *= 24
    h = int(f)
    return '{}:{:02d}'.format(h, round((f - h) * 60))


def make_surface(args):
    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, args.w, args.h)
    cr = cairo.Context(surface)
    radius = args.h / 2

    sun = sun_info(args)

    # Clear background.
    cr.rectangle(0, 0, args.w, args.h)
    cr.set_source_rgb(*[float(f) for f in args.color_background.split(',')])
    cr.fill()

    # Zoom and auto-pan.
    cr.save()
    if 0.25 < sun['current'] < 0.75:
        cr.translate(args.zoom * radius, args.zoom * radius)
    else:
        cr.translate(args.zoom * radius, 2 * radius - args.zoom * radius)
    cr.scale(args.zoom, args.zoom)

    # Two arcs: One for night, one for day. Note that we have to begin
    # drawing at the circle's center to get an actual "pizza" segment.
    cr.move_to(0, 0)
    cr.arc(0, 0, radius,
        -sun['set'] * 2 * pi + pi / 2,
        sun['rise'] * 2 * pi + pi / 2,
    )
    cr.set_source_rgb(*[float(f) for f in args.color_night.split(',')])
    cr.fill()

    cr.move_to(0, 0)
    cr.arc(0, 0, radius,
        sun['rise'] * 2 * pi + pi / 2,
        sun['set'] * 2 * pi + pi / 2,
    )
    cr.set_source_rgb(*[float(f) for f in args.color_day.split(',')])
    cr.fill()

    # Indicate noon.
    cr.save()
    cr.move_to(0, 0)
    cr.line_to(
        radius * sin(-sun['noon'] * 2 * pi),
        radius * cos(-sun['noon'] * 2 * pi),
    )
    cr.set_source_rgb(*[float(f) for f in args.color_noon.split(',')])
    cr.set_line_width(args.width_noon / args.zoom)
    cr.stroke()
    cr.restore()

    # Indicate current sun position.
    cr.save()
    dot_radius = 0.15 * radius
    cr.arc(
        (0.95 * radius - dot_radius) * sin(-sun['current'] * 2 * pi),
        (0.95 * radius - dot_radius) * cos(-sun['current'] * 2 * pi),
        dot_radius,
        0,
        2 * pi,
    )
    cr.set_source_rgb(*[float(f) for f in args.color_now.split(',')])
    cr.fill_preserve()
    cr.set_source_rgb(*[float(f) for f in args.color_background.split(',')])
    cr.set_line_width(args.width_now / args.zoom)
    cr.stroke()
    cr.restore()

    # Revert zoom/pan.
    cr.restore()

    # Text labels.
    # (It's important to set font size before calling text_extents().)
    cr.set_font_size(args.size_font)
    margin = 2

    l = float_to_time(sun['rise'])
    _, _, tw, _, _, _ = cr.text_extents(l)
    shadowed_text(cr, args, args.w - tw - margin - 1, args.size_font, l)

    l = float_to_time(sun['set'])
    _, _, tw, _, _, _ = cr.text_extents(l)
    shadowed_text(cr, args, args.w - tw - margin - 1, args.h - margin, l)

    return surface


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument('w', type=int)
    parser.add_argument('h', type=int)
    parser.add_argument('--antialias-font', action='store_true')
    parser.add_argument('--color-background', default='0,0,0.33')
    parser.add_argument('--color-day', default='1,0.73,0.45')
    parser.add_argument('--color-font', default='1,1,1')
    parser.add_argument('--color-font-shadow', default='0,0,0')
    parser.add_argument('--color-night', default='0.45,0.71,1')
    parser.add_argument('--color-noon', default='0.3,0.3,0.3')
    parser.add_argument('--color-now', default='1,0,0')
    parser.add_argument('--lat', type=float, default=50)
    parser.add_argument('--lon', type=float, default=8)
    parser.add_argument('--size-font', type=int, default=8)
    parser.add_argument('--width-noon', type=float, default=0.25)
    parser.add_argument('--width-now', type=float, default=0.75)
    parser.add_argument('--zoom', type=float, default=1.5)
    args = parser.parse_args()

    if args.zoom < 1 or args.zoom > 2:
        print('Error: --zoom must be >= 1 and <= 2', file=stderr)
        exit(1)

    write_ff(make_surface(args))
